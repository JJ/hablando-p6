<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>CommitConf19: D√©jame que te hable de Raku</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    <link rel="stylesheet" href="css/extra.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section data-background='https://live.staticflickr.com/1848/44400270572_2c612c07f5_k_d.jpg'>
	  <h1>D√©jame que te hable de Raku</h1>
	  <h2><code>@jjmerelo</code></h2>
          <h2><code>cc-by-sa</code></h2>
          <aside class='notes'>Inspirado un mont√≥n por <a
        href='https://medium.com/@kasperpeulen/10-features-from-various-modern-languages-that-i-would-like-to-see-in-any-programming-language-f2a4a8ee6727'>este
            y otros art√≠culos similares.</a>. Tambi√©n por <a
        href='https://therenegadecoder.com/code/the-coolest-programming-language-features/'>este
              de The Renegade Coder</a>. Raku <a href='https://es.wikipedia.org/wiki/Raku'>es un tipo de porcelana japonesa</a>, y el ideograma se usa tambi√©n para "felicidad" o "tranquilidad". El uso de metales para resaltar las grietas creadas en el proceso se llama Kintsugi. Y ya van dos commits. Ya va siendo hora de que hagan un push.
	  </aside>
        </section>

	<section data-background='https://live.staticflickr.com/65535/48549954721_0a93aa703f_k_d.jpg'>
          <h1><em>Previamente conocido como Perl 6</em></h1>
        </section>

	<section>
          <section
            data-background='https://live.staticflickr.com/65535/2510199573_b9d6625c5c_o_d.jpg'>
            <h1>Pero antes...</h1>
          </section>

          <section data-background='https://live.staticflickr.com/65535/46794874715_bf1671749e_k_d.jpg'>
            <h2>Hablemos de cosas que importan... </h2>
	    <h1 class='fragment'>... y molan ...</h1>
	    <h2 class='fragment'>... en lenguajes de programaci√≥n modernos.</h2>
          </section>
        </section>
	
	<!-- Unicode -->
	<section>
	  
	  <section data-background='https://live.staticflickr.com/65535/47925314648_9d71567b99_b_d.jpg'><h1>Unicode</h1>
	    <h2 class='fragment'>es</h2>
	    <h2 class='fragment'>importante</h2>
	    <aside class='notes'>Hasta Python, en su versi√≥n 3, se ha dado cuenta. "Oye, Guido, que igual estos garabatillos y eso, que vamos, que se usan mucho". Pero vamos a empezar por otro lenguaje m√°s popular: JavaScript.</aside>
	  </section>
	  
	  <section><h1>Me suena a griego</h1>
	    <pre><code>function isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨(input) {
  const rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ = /^\p{Script=Greek}$/u
  return rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨.test(input)
}
console.log(isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨('œÄ'));
	    </code></pre>

	    <aside class='notes'>He tratado de buscar soporte en alg√∫n
	    lenguaje para aritm√©tica con d√≠gitos Unicode, y no lo he
	    encontrado. El √∫nico lenguaje que lo tien ees Perl 6
	    aparentemente. A√±adir (posiblemente) soporte para
	    operadores Unicode en Julia. Unicode no s√≥lo permite
	    trabajar en lenguaje "natural" (no ingl√©s), sino que las
	    expresiones se parezcan m√°s a matem√°ticas y f√≠sica.</aside>
	  </section>

	  <section><h1>Operadores en Julia</h1>
	    <pre><code>function puntuaci√≥n(carta::Int)
    carta == 1 && return 11
    carta == 3 && return 10
    (carta ‚â• 4 && carta ‚â§ 9 ) && return 0
    carta ‚àà 10:12 && return carta - 8
    return 0
end
for i ‚àà (2,3,5,11)
    println("Puntuaci√≥n de\t", i, "\t‚Üí ", puntuaci√≥n(i) )
end </code></pre>
	    <aside class='notes'>Julia usa los operadores en su
	      notaci√≥n matem√°tica con toda la naturalidad del mundo.</aside>
	  </section>

	</section>


	<section data-background='https://live.staticflickr.com/1787/29383187738_17130b8d3b_k_d.jpg'>
	  <h1>La programaci√≥n funcional...</h1>
	  <h2 class='fragment'>... Funciona</h2>
	</section>
	
	<!-- Lambda -->
	<section>
	  <section data-background='https://live.staticflickr.com/921/42478047325_b5f9dd1884_k_d.jpg'><h1>Œª FTW</h1>
	      <aside class='notes'>Funciones como datos, la esencia de
	      la programaci√≥n funcional. Como explican
	      aqu√≠: <a href='https://gist.github.com/ericelliott/414be9be82128443f6df'>lambdas
	      no s√≥lo son funciones an√≥nimas</a>. </aside>
	    </section>
	    
	    <section><h1>Œª es lambda en Python</h1>
	      <pre><code>from functools import reduce;

def fib(n):
    return reduce( lambda prev,this: prev+[ prev[-2]+prev[-1] ], \
                   range(1,n+1), \
                   [1,1] )

print(fib(12)) </code></pre>
	      <p class='fragment' data-code-focus="4">Œª üò∫</p>
	      <aside class='notes'>Se usa reduce con tres argumentos,
	      el √∫ltimo de los cuales es el inicializador. Lambda est√°
	      ah√≠ desde la versi√≥n 3, pero tambi√©n en Java desde la 7,
	      y creo que ahora hasta en C++, o sea que casi se est√°
	      convirtiendo en un est√°ndar para los lenguajes que
		molan. 
	      </aside>
	    </section>

	    <section><h1>Y en Go</h1>
	      <pre><code>func main() {
	puntuaci√≥n := func(valor int) int {
		switch valor {
		case 1:
			return 11
		case 3:
			return 10
		case 10, 11, 12:
			return valor - 8
		default:
			return 0
		}
	}
	fmt.Println( puntuaci√≥n( 1 ) )
	fmt.Println( puntuaci√≥n( 3 ) )
} </code></pre>
	      <p class='fragment' data-code-focus="2">Œª üò∫</p>
	      <aside class='notes'>Este es un ejemplo cl√°sico de Go, y
	      no tiene nada que ver con el pattern matching que hemos
		visto anteriormente. Aqu√≠ empezamos a hacer los chistes de cartas e Inteligencia artificial.</aside>
	    </section>
	</section>
	
	  <!-- Inmutabilidad -->
	  <section>
	    <section data-background='https://live.staticflickr.com/8601/16187820372_6eb950631c_k_d.jpg'>
	      <h1>Inmutabilidad para programaci√≥n r√°pida y segura</h1>
	      <aside class='notes'>Sin efectos secundarios,
		optimizando el acceso a los datos.</aside>
	    </section>
	    
	    <section data-background='https://live.staticflickr.com/719/20709221798_984671b12e_k_d.jpg'>
	      <h1>Lo que es inmutable no se puede cambiar</h1>
	      <aside class='notes'>Ni extender, ni se puede acceder a
	      m√©todos que lo cambien, ni nada. Si algo parece que lo
	      cambia, es porque se genera uno nuevo. Permite trabajar
	      con funciones puras, es m√°s f√°cil de testear  ‚Üí
	      programaci√≥n reactiva.</aside>
	    </section>
	    
	    <section data-background='https://live.staticflickr.com/65535/49098112218_d4f2be8907_k_d.jpg'>
	      <h1>Escalando la inmutabilidad</h1>
	      <pre><code>val no = "me cambies"</code></pre>
	    </section>

	    <section><h1>¬øBucles? No, gracias.</h1>
	      <pre><code>(defn hasta-cero [n]
  (if (> n 0)
    (do
      (print n, "... ")
      (hasta-cero (dec n))
      )
    )
  )

(hasta-cero 3)
	      </code></pre>
	      <p class="fragment"
		 data-code-focus="1">Funci√≥n <code>hasta-cero</code></p>
	      <p class="fragment" data-code-focus="5">... recursiva</p>
	      <aside class='notes'>Inmutabilidad y recursi√≥n van de la mano. No hay una variable de bucle que cambie de valor, sino un argumento inmutable que pasa de una funci√≥n a otra.</aside>
	    </section>
	  </section>


	  <!-- Programaci√≥n as√≠ncrona -->
	  <section>
	    <section data-background='https://live.staticflickr.com/65535/40744489923_18185ae657_o_d.jpg'>
	      <h1>El mundo funciona de forma as√≠ncrona</h1></section>

	    <section><h3>Dart tambi√©n</h3>
	      <pre><code>Future listaBackups(String dir) async {
  var directory = new Directory(dir);
  if ( await directory.exists() ) {
    directory.list(recursive: true, followLinks: false).listen((FileSystemEntity entity) {
        if ( entity.path.contains("car") ) {
          print( entity.path );
        }
    });
  }
}
Future&lt;void> main() async {
  var files = listaBackups( ".");
  print("Pillando ficheros");
  await files;
}</code></pre>
	      <p class='fragment' data-code-focus='1,3,4,11,12,13'>Async espero</p>
	      <aside class='notes'>Muchos lenguajes son as√≠ncronos, porque aprovechan mejor los recursos del procesador.</aside>
	    </section>
	  </section>


	  <!-- Pattern matching -->
          <section>
          <section data-background='https://live.staticflickr.com/900/27194796608_53fdbea2eb_k_d.jpg'>
            <h1>Comparaci√≥n de patrones para decisiones complejas</h1>
            <h2 class='fragment'>Evitando cascadas de
              <code>if</code></h2>
          </section>
          <section><h1>Scalando la comparaci√≥n</h1>
            <pre><code>val puntos = (carta: String) => {
  carta match {
    case "As" => 11
    case "3"  => 10
    case "J"  => 2
    case "Q"  => 3
    case "K"  => 4
    case  _   => 0
  }
}
println("As ", puntos("A"))
println("7 ", puntos("7"))</code></pre>
	    <p><span class='fragment' data-code-focus="2">Matching!</span> <span class='fragment' data-code-focus="1">y <strong>Œª üò∫</strong></span></p>
	    <aside class='notes'>Usando tambi√©n un lambda
              aqu√≠, como casi siempre. La mayor√≠a de los lenguajes
              funcionales tienen este tipo de comparaci√≥n de
              patrones. Sorprendentemente, este programa sali√≥ a la
              primera. Pero a veces hay que enganchar las entradas de
              uno con las salidas de otro...</aside>
          </section>
          </section>
          
	  <!-- Pipeline/Cascade operators -->

          <section>
            <section data-background='https://live.staticflickr.com/65535/48847315062_e959f270b7_k_d.jpg'>
	      <h1>Cuando hay que enganchar operaciones:
              cascadas</h1>
              <aside class='notes'>Se trata de otra caracter√≠stica de
            programaci√≥n funcional, como casi todo. Esta funcionalidad
            te permite "seguir" el flujo de los datos f√°cilmente, pero
            tambi√©n te fuerza a pensar en t√©rminos de aplicaciones de
                unos dominios a otros dominios.</aside>
            </section>
            <section><h1>Tengo un Elixir para eso</h1>
              <pre><code>resultado = 1..100
      |> Enum.filter(fn a -> rem(a,2) == 0 end)
      |> Enum.map(fn a -> :math.pow(a,2) end)
      |> Enum.reduce( &(&1 + &2) )

IO.puts  resultado</code></pre>
	      <p class='fragment' data-code-focus="2-4">Enganchando</p>
	      <p class='fragment' data-code-focus="2">Œª üò∫</p>
	      <aside class='notes'>Obs√©rvese no s√≥lo el
              uso de lambdas, sino el uso de las mismas con datos
                impl√≠citos. Otra cosa funcional a la buchaca</aside>
            </section>
          </section>

	  <!-- Laziness -->
          <section>
            <section><h1>Los perezosos heredar√°n la Tierra</h1>
              <h2 class='fragment'>Evaluaci√≥n perezosa FTW</h2>
              <aside class='notes'>Otra caracter√≠stica (m√°s) de
          programaci√≥n funcional, permite trabajar con estructuras de
                datos infinitas y retrasar la evaluaci√≥n hasta que sea
          necesaria. Puede tener <a
          href='https://softwareengineering.stackexchange.com/questions/124500/why-isnt-lazy-evaluation-used-everywhere'>una
                serie de desventajas</a>, sin embargo. M√°s <a
          href='https://www.seas.upenn.edu/~cis194/fall16/lectures/07-laziness.html'>ventajas
                y desventajas</a></aside>
            </section>

            <section><h1>Pereza en F#</h1>
              <pre><code>let horadam =
    (0.0f, 1.0f) 
    |> Seq.unfold (fun (x, y) -> let z = 0.25f*x + 0.75f*y in Some(z, (y, z))) 
    |> Seq.append [0.0f; 1.0f]

let seq_15 = horadam |> Seq.take 15
printfn "Primeros 15 %A" seq_15
              </code></pre>
	      <p class='fragment' data-code-focus="3">üò¥</p>
	      <p class='fragment' data-code-focus="1">Œª üò∫</p>

              <aside class='notes'>Tambi√©n se usan lambdas y "pipes",
                dos cosas caracter√≠sticas de programaci√≥n
                funcional. El hecho de que sea infinita est√° impl√≠cita
                en la definici√≥n de la estructura de datos, que es una
                secuencia. F# no es perezoso por omisi√≥n como Haskell,
                pero permite trabajar f√°cilmente con este tipo de
                cosas. </aside>
            </section>
          </section>


          <!-- Gradual typing -->
	  <section>
            <section><h1>Tipado gradual: lo mejor de los dos
		mundos</h1>
	      <pre><code>let secondNeedle: number = 3
let firstNeedle = "Hey"</code></pre>
              <h2 class='fragment' data-code-focus='1'>Est√°tico </h2>
	      <h2 class='fragment' data-code-focus='2'>Din√°mico </h2>
            </section>
            <section><h1>Juntos en TypeScript</h1>
              <pre><code>let find = function ( needle, haystack ) {
    for (let i of haystack) {
        if ( needle === i ) {
            return true
        }
    }
    return false;
}
let randomList = ["Hey", 3]
let firstNeedle = "Hey"
let secondNeedle: number = 3
console.log( find( firstNeedle, randomList ) )
console.log( find( secondNeedle, randomList  ) )
              </code></pre>
	      <p><span class='fragment' data-code-focus='10,11'>Con y sin tipo</span> <span class='fragment' data-code-focus="1">y <strong>Œª üò∫</strong></span></p>
                <aside class='notes'>N√≥tese que tambi√©n tenemos una
	  lambda ah√≠ al principio. Informaci√≥n sobre <a
							href='https://golem.ph.utexas.edu/category/2018/02/gradual_typing.html'>gradual typing</a>. Cada funci√≥n tiene un tipo diferente, y el int√©rprete decide qu√© tipo tiene basado en lo que recibe.

		</aside>
            </section>
          </section>

	  <!-- Destructuring -->
          <section>
            <section data-background='https://live.staticflickr.com/7865/47538183412_4122017573_k_d.jpg'>
	      <h1>Asignaci√≥n postmoderna: desestructurando
              argumentos</h1>
              <h2 class='fragment'>Asignaci√≥n segura en una sola
                orden</h2>
              <aside class='notes'>Una serie de razones por las que
            esto es chulo: <a
            href='https://css-tricks.com/new-favorite-es6-toy-destructured-objects-parameters/'>referido
                a ES6 y a argumentos de funci√≥n</a></aside>
            </section>

            <section><h1>Desestructurando en Kotlin</h1>
              <pre><code>data class Resultado (val resultado: Int, val tesoro: Boolean)
fun main(args: Array&lt;String>) {
        val busca =  fun(intento: Int): Resultado
        {
                val cosas = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( intento == 4  ) {
                        return Resultado( 42, true )
                } else {
                        return Resultado( cosas[intento], false )
                }
        }
        val (valor1, premio1) = busca( 2 )
        println( "2 devuelve " + valor1 + " y tiene premio " + premio1  )
        val (valor2, premio2) = busca( 4 )
        println( "4 devuelve " + valor2 + " y tiene premio " + premio2  )
}
              </code></pre>
	      <p><span class='fragment' data-code-focus="7,9,12">Deconstruyendo</span> <span class='fragment' data-code-focus="3">y <strong>Œª üò∫</strong></span></p>
              <aside class='notes'>Por medio, <a
              href='https://stackoverflow.com/questions/56252911/i-get-the-error-no-main-manifest-attribute-when-compiling-and-running-a-simpl/56253260#56253260'>esta
                pregunta en StackOverflow</a>. Tambi√©n usamos un lambda.</aside>
            </section>
          </section>
          
          
	  <!-- Multiple dispatch -->
          <section>
            <section data-background='https://live.staticflickr.com/8252/29175359022_a09f2d8a08_k_d.jpg'><h1>Env√≠o m√∫ltiple ‚áí <em>Multiple
              dispatch</em></h1>
              <h2 class='fragment'>Implementaciones r√°pidas a su
                servicio</h2>
              <aside class='notes'>No es lo mismo que <a
              href='http://wiki.c2.com/?MultipleDispatch'>Overloading</a>,
              porque se puede hacer con subrutinas y se trata de
                identificar los argumentos, no el tipo que lo invoca.</aside>
              
            </section>

            <section>
	      <h1>Pintan bastos con Julia</h1>
              <pre><code>@enum Suit ‚ô£ ‚ô¶ ‚ô• ‚ô†
@enum Palo Bastos Espadas Oros Copas

cadena( n::Int, s::Suit ) = string( n, " ", s )
cadena( n::Int, p::Palo ) = string( n, " de ", p )

println( cadena( 3, ‚ô¶) )
println( cadena( 7, Bastos ) )
            </code></pre>
	      <p class='fragment' data-code-focus='4,5'>Definici√≥n. Y, s√≠, <strong>Œª üò∫</strong></p>
              <aside class='notes'>Hay muchos tipos de env√≠o m√∫ltiple
              que var√≠an con la signatura, lo que ocurre es que la
              signatura tiene un concepto mucho m√°s concreto en Julia
              que en Raku, donde incluye tambi√©n restricciones a los
                valores de los argumentos.</aside>
            </section>
          </section>

          
	  <!-- Traits (with type tunnelling) -->
          <section>
            <section data-background='https://live.staticflickr.com/65535/49109722841_40f491724c_o_d.jpg'>
	      <h1>Composici√≥n mejor que herencia</h1>
              <h2 class='fragment'><em>Traits</em>, <em>mixins</em> y
                roles</h2>
              <aside class='notes'>Aunque cada lenguaje usa su
          definici√≥n, aparentemente los traits son interfaces
          abstractos y no incluyen estado, mientras que los mixins
          s√≠. En algunos lugares se les llama modules (en Ruby). Roles
                aparentemente pueden ser o una cosa o la otra.</aside>
            </section>

            <section><h1>Traits seguros con Rust</h1>
              <pre><code>struct Carta { figura: String, palo: &'static str }
trait Mira {
    fn mira(self ) -> String;
}
impl Mira for Carta  {
    fn mira(self ) -> String {
        self.figura + " de " + self.palo
    }
}
fn main() {
    let as_de_bastos = Carta { figura: "As".to_string(),
                               palo: "Bastos"
    };
    println!( "Carta ‚Üí {}", as_de_bastos.mira() );
}</code></pre>
	      <p><span class='fragment' data-code-focus="2"><em>Trait</em></span> <span class='fragment' data-code-focus="5">e <strong>implementaci√≥n</strong></span></p>
              <aside class='notes'>Aunque en realidad los de Raku
    son bastante m√°s flexibles y se pueden a√±adir en tiempo de
    ejecuci√≥n, esto es lo que hay en Rust, donde adem√°s se separan las
    variables de instancia de la implementaci√≥n. Y con esto terminan
    las diez caracter√≠sticas chulas. Hay muchas m√°s, pero estas son
                bastante sobresalientes.</aside>
            </section>
            
          </section>

	<section data-background='https://live.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'>
	  <h1>JJ Merelo</h1>
	  <h2><code>@jjmerelo</code> <a href='https://github.com/JJ'><code>github.com/JJ</code></a></h2>
	  <aside class='notes'>Trabajo en la universidad, en la documentaci√≥n de Raku, y todo ese rollo</aside>
	</section>

        <section><h1>Pregunta inocente</h1>
          <h2 class='fragment'>¬øCuantos de estos conceptos se ense√±an
            en las universidades?</h2>
          <h3 class='fragment'>(Vale, quiz√°s no tan inocente)</h3>
        </section>
        
        <section>
          <section data-background='https://live.staticflickr.com/65535/47120739724_61b9bd3a45_k_d.jpg'><h1>¬øD√≥nde est√° Raku?</h1></section>
          <section data-background='https://live.staticflickr.com/65535/47910069711_0fb7075c91_k_d.jpg'><h1>Raku est√° en todos</h1>
          </section>
          <section><h1>Tard√© un rato en hacerlos</h1>
            <h2 class='notes'>Pero no por el concepto, sino por la
              sintaxis</h2>
            <aside class='notes'>Bueno, y por descargar el modo en
          emacs, instalar el programa en s√≠... El que m√°s ha costado
              ha sido Rust, y el que menos Elixir.</aside>
          </section>
        </section>

        <section>
          <section data-background='https://live.staticflickr.com/65535/40943471043_5226aa62ad_k_d.jpg'>
            <h1>Raku: todo <strong>y adem√°s, el
              fregadero</strong></h1></section>
          <section><pre><code>multi sub collatz( 1 ) { return [1] }
multi sub collatz( Int $a where $a %% 2 ) { return  collatz( ($a/2).Int ).prepend( $a )}
multi sub collatz( $a where not $a %% 2 ) { return collatz( $a*3 + 1 ).prepend($a)}

my @collatz = lazy gather for Ÿ°..Ÿ°Ÿ†Ÿ†Ÿ† { take collatz( $_ ); }

1..100 ==> map( { @collatz[ $_ ] }) ==> grep( *.elems > 15 ) ==> my @long-chains;

sub prefix:<‚áà> ( $ùíæ ) {
    given @collatz[ $ùíæ ].elems {
        when $_ > 15 { return @collatz[ $ùíæ ] but "Collatz", @collatz[ $ùíæ ].elems }
        default  { @collatz[ $ùíæ ], @collatz[ $ùíæ ].elems }
    }
}

for ^10 -> $√æ {
    my ($seq, $elems) = ‚áà$√æ;
    say "Secuencia con $√æ ", $seq.?Str eq "Collatz" ?? " es " !! " no es " , "Collatz";
}
          </code></pre>
	    <p class='fragment' data-code-focus='2,3,5'>Fregadero</p>
            <aside class='notes'><a
    href='https://es.wikipedia.org/wiki/Conjetura_de_Collatz'>Conjetura
    de Collatz</a>. Este programa tiene todas las caracter√≠sticas
    chulas de las que hemos hablado anteriormente. Y algunas que no
    tiene ninguno, como los rangos en el sentido correcto de escritura
    y usando d√≠gitos Unicode. No he metido llamada as√≠ncona, pero se puede hacer tambi√©n.</aside>

          </section>
          <section><h1>Aprende Raku para aprender <em>todos</em> los
            lenguajes</h1>
            <h2 class='fragment'>O al menos los que molan</h2>
          </section>

	</section>
	
        <section
            data-background='https://live.staticflickr.com/4748/39219833084_2a18eecdd8_k_d.jpg'><h1>¬øPreguntas?</h1>
            <h2 class='fragment'>¬øComentarios?</h2>
            <aside class='notes'>"La ni√±a del huevo", de √Ångeles
            Santos, una maravilla. Espero que no os hay√°is dormido
              como ella.</aside>
        </section>

          

      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
     Reveal.initialize({
       width: '95%',
       controls: true,
       progress: true,
       history: true,
       dependencies: [
	 { src: 'plugin/notes/notes.js', async: true },
     { src: 'plugin/highlight/highlight.js', async: true },
     {
     src: 'plugin/reveal-code-focus/reveal-code-focus.js',
     async: true,
     callback: function() {
     RevealCodeFocus();
     }
     }
       ]
     });
    </script>
  </body>
</html>
