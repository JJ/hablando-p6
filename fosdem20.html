<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>FOSDEM emerging languages devroom: Let me tell you about Raku</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    <link rel="stylesheet" href="css/extra.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section data-background='https://live.staticflickr.com/2241/1576385307_b195b21468_o_d.jpg'>
	  <h1>Let me tell you about Raku</h1>
	  <h2><code>@jjmerelo</code> | <a href='https://jj.github.io/hablando-p6/fosdem.html'><code>git.io/raku-fosdem20</code></a></h2>
          <h3><code>cc-by-sa</code></h3>
	</section>

        <section data-background='https://live.staticflickr.com/619/20996949839_9be1423b2c_k_d.jpg'>
          <h1>Previously known as</h1>
          <h2 class='fragment'>Perl 6</h2>
        </section>

        <section data-background='https://live.staticflickr.com/5151/6948163750_f77c60dae6_k_d.jpg'><h2>Long story short</h2>
          <h1 class='fragment'>It's a different language</h1>
	  <aside class='notes'>As the person talking about guile said, hillclimbing is OK but eventually you get stuck. Perl was at that phase, Perl 6 was intended to take it a bit further, eventually it (almost) totally broke away with it.</aside>
        </section>

	<section data-background='https://live.staticflickr.com/7921/46812657474_b8d0df40aa_o_d.jpg'><h2>But still</h2>
	  <h1 class='fragment'>TIMTOWTDI</h1>
	  <aside class='notes'>There is more than one way to do it, and it's also the nickname of Larry Wall, creator of both.</aside>
	</section>

	<section data-background='https://live.staticflickr.com/2269/32028784543_2aec0c64d5_k_d.jpg'><h2>So</h2>
	  <h1 class='fragment'>Let me tell you about Raku</h1>
	</section>

        <section data-background='https://live.staticflickr.com/65535/2510199573_b9d6625c5c_o_d.jpg'>
          <h2>But previously</h2>
          <h1 class='fragment'>What do many cool emerging languages do?</h1>

          <aside class='notes'>Inspirado un mont√≥n por <a
        href='https://medium.com/@kasperpeulen/10-features-from-various-modern-languages-that-i-would-like-to-see-in-any-programming-language-f2a4a8ee6727'>este
            y otros art√≠culos similares.</a>. Tambi√©n por <a
        href='https://therenegadecoder.com/code/the-coolest-programming-language-features/'>este
            de The Renegade Coder</a>.</aside>
        </section>
        
	<!-- Unicode -->
	<section>
	  <section data-background='https://live.staticflickr.com/65535/47925314648_9d71567b99_b_d.jpg'><h1>Unicode</h1>
	    <h2 class='fragment'>is</h2>
	    <h2 class='fragment'>important</h2>
	  </section>
	  <section><h1>It's all Greek to me</h1>
	    <pre><code>function isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨(input) {
  const rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ = /^\p{Script=Greek}$/u
  return rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨.test(input)
}
console.log(isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨('œÄ'));
	    </code></pre>

	    <aside class='notes'> As a matter of fact, Raku is the
	  only one with good Unicode arithmetic support; many
	  languages can use unicode for strings, and some more can use
	  it for regular expressions.</aside>
	  </section>
	</section>

	<!-- Lambda -->
	  <section>
	    <section data-background='https://live.staticflickr.com/1898/42559301890_63a4eb58e8_k_d.jpg'><h1>Œª FTW</h1>
              <h1>+ Immutability</h1>
	      <aside class='notes'>Funciones como datos, la esencia de
	  la programaci√≥n funcional. Como explican aqu√≠: <a
	  href='https://gist.github.com/ericelliott/414be9be82128443f6df'>lambdas
	  no s√≥lo son funciones an√≥nimas</a>. This is the first step
	  to a language having functional features; it's not all. Ni
	  extender, ni se puede acceder a m√©todos que lo cambien, ni
	  nada. Si algo parece que lo cambia, es porque se genera uno
	  nuevo. Permite trabajar con funciones puras, es m√°s f√°cil de
	  testear. These are two functional features that got
	  everywhere.</section>

	    <section data-background='https://live.staticflickr.com/4806/31057964327_dc046005ee_k_d.jpg'>
	      <h2>Warning: your loops are deprecated</h2>
	      <pre><code>(def elipsis (fn [n] (print "... ", n ) ))

(defn to-zero [n]
  (if (> n 0)
    (do
      (elipsis [n])
      (to-zero (dec n))
      )
    )
  )

(to-zero 3)</code></pre>
	      <aside class='notes'>Inmutabilidad y recursi√≥n van de la mano. No hay una variable de bucle que cambie de valor, sino un argumento inmutable que pasa de una funci√≥n a otra.</aside>
	    </section>
	  </section>
	  
	  <!-- Gradual typing and destructuring -->
          <section>
            <section><h1>Postmodern assignment:</h1>
              <h2 class='fragment'>Destructuring arguments</h2>
              <h2 class='fragment'>Gradual typing</h2>

              <aside class='notes'>Flexible, allows many different
            ways of dealing with variables, but it's also typesafe;
            but destructuring is also very typesafe, since you can
            create several variables out of one simple, structured,
            one. Una serie de razones por las que
            esto es chulo: <a
            href='https://css-tricks.com/new-favorite-es6-toy-destructured-objects-parameters/'>referido
                a ES6 y a argumentos de funci√≥n</a></aside>
            </section>

            <section><h1>Kotlin and Derrida</h1>
              <pre><code>data class Result (val result: Int, val treasure: Boolean)
fun main(args: Array&lt;String>) {
        val search =  fun(attempt: Int): Result
        {
                val things = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( attempt == 4  ) {
                        return Result( 42, true )
                } else {
                        return Result( things[attempt], false )
                }
        }
        val (value1, prize1) = search( 2 )
        println( "2 returns " + value1 + prize( prize1 )  )
        val (value2, prize2) = search( 4 )
        println( "4 returns " + value2 + prize( prize2 )  )
}              </code></pre>
              <aside class='notes'>Por medio, <a
              href='https://stackoverflow.com/questions/56252911/i-get-the-error-no-main-manifest-attribute-when-compiling-and-running-a-simpl/56253260#56253260'>esta
                  pregunta en StackOverflow</a>. Tambi√©n usamos un
              lambda. Derrida is the father of <a href='https://en.wikipedia.org/wiki/Jacques_Derrida'>Deconstruction</a></aside>
            </section>
          </section>
          
	  <!-- Pattern matching -->
          <section>
          <section data-background='https://live.staticflickr.com/98/248298523_e53c4a51a2_o_d.jpg'>
            <h1>Pattern matching for complex decisions</h1>
            <h2 class='fragment'>Avoiding <code>if</code> cascades</h2>
          </section>
          <section><h1>Scala-ing comparison</h1>
            <pre><code>val points = (card: String) => {
  card match {
    case "Ace" => 11
    case "3"  => 10
    case "J"  => 2
    case "Q"  => 3
    case "K"  => 4
    case  _   => 0
  }
}

println("Ace ", points("Ace"))
println("7 ", points("7"))</code></pre><aside class='notes'>Usando tambi√©n un lambda
              aqu√≠, como casi siempre. La mayor√≠a de los lenguajes
              funcionales tienen este tipo de comparaci√≥n de
              patrones. Sorprendentemente, este programa sali√≥ a la
              primera. Pero a veces hay que enganchar las entradas de
              uno con las salidas de otro...</aside>
          </section>
          </section>

	  <!-- Multiple dispatch -->
          <section>
            <section><h1>Multiple dispatch</h1>
              <h2 class='fragment'>High performance implementation at your
                service</h2>
              <aside class='notes'>No es lo mismo que <a
              href='http://wiki.c2.com/?MultipleDispatch'>Overloading</a>,
              porque se puede hacer con subrutinas y se trata de
                identificar los argumentos, no el tipo que lo invoca. Although at the end of the day the object is another argument, so it¬°s pretty much the same.
	      </aside>

            </section>

            <section><h1>Suit up with Julia</h1>
              <pre><code>@enum Suit ‚ô£ ‚ô¶ ‚ô• ‚ô†
@enum Palo Bastos Espadas Oros Copas

toString( n::Int, s::Suit ) = string( n, " ", s )
toString( n::Int, p::Palo ) = string( n, " de ", p )

println( toString( 3, ‚ô¶) )
println( toString( 7, Bastos ) ) </code></pre>
              <aside class='notes'>Hay muchos tipos de env√≠o m√∫ltiple
              que var√≠an con la signatura, lo que ocurre es que la
              signatura tiene un concepto mucho m√°s concreto en Julia
              que en Raku, donde incluye tambi√©n restricciones a los
                valores de los argumentos. </aside>
            </section>
          </section>

	  <!-- Laziness and cascading -->
          <section>
            <section data-background='https://live.staticflickr.com/1847/43736329804_1ab7461a70_k_d.jpg'>
	      <h1>Sloths will inherit the earth</h1>
              <h2 class='fragment'>Lazy evaluation FTW</h2>
              <h2 class='fragment'>Great for propagating: cascading</h2>
	      
              <aside class='notes'>Otra caracter√≠stica (m√°s) de
          programaci√≥n funcional, permite trabajar con estructuras de
                datos infinitas y retrasar la evaluaci√≥n hasta que sea
          necesaria. Puede tener <a
          href='https://softwareengineering.stackexchange.com/questions/124500/why-isnt-lazy-evaluation-used-everywhere'>una
                serie de desventajas</a>, sin embargo. M√°s <a
          href='https://www.seas.upenn.edu/~cis194/fall16/lectures/07-laziness.html'>ventajas
                  y desventajas. I am also too lazy to look up a picture of a sloth, so you'll have to make do with plush penguins, which are lovely
	      </a></aside>
            </section>

            <section><h1>Lazy and cascaded in F#</h1>
              <pre><code>let horadam =
    (0.0f, 1.0f) 
    |> Seq.unfold (fun (x, y) -> let z = 0.25f*x + 0.75f*y in Some(z, (y, z))) 
    |> Seq.append [0.0f; 1.0f]


let seq_15 = horadam |> Seq.take 15
printfn "First 15 %A" seq_15
              </code></pre>
              <aside class='notes'>Tambi√©n se usan lambdas y "pipes",
                dos cosas caracter√≠sticas de programaci√≥n
                funcional. El hecho de que sea infinita est√° impl√≠cita
                en la definici√≥n de la estructura de datos, que es una
                secuencia. F# no es perezoso por omisi√≥n como Haskell,
                pero permite trabajar f√°cilmente con este tipo de
                cosas. </aside>
            </section>
          </section>
          
	  <!-- Traits (with type tunnelling) -->
          <section>
            <section><h1>Inheriting << composing</h1>
              <h2 class='fragment'><em>Traits</em>, <em>mixins</em> and
                roles</h2>
              <aside class='notes'>Aunque cada lenguaje usa su
          definici√≥n, aparentemente los traits son interfaces
          abstractos y no incluyen estado, mientras que los mixins
          s√≠. En algunos lugares se les llama modules (en Ruby). Roles
                aparentemente pueden ser o una cosa o la otra.</aside>
            </section>

            <section><h1>Safe Rust-y traits</h1>
              <pre><code>struct Card { value: String, suit: &'static str }

trait Lookup {
    fn lookup(self ) -> String;
}

impl Lookup for Card  {
    fn lookup(self ) -> String {
        self.value + " of " + self.suit
    }
}

fn main() {
    let ace_of_clubs = Card { value: "Ace".to_string(),
                               suit: "‚ô£"
    };
    println!( "Card ‚Üí {}", ace_of_clubs.lookup() );
}

              </code></pre>
              <aside class='notes'>Aunque en realidad los de Raku
    son bastante m√°s flexibles y se pueden a√±adir en tiempo de
    ejecuci√≥n, esto es lo que hay en Rust, donde adem√°s se separan las
    variables de instancia de la implementaci√≥n. Y con esto terminan
    las diez caracter√≠sticas chulas. Hay muchas m√°s, pero estas son
                bastante sobresalientes.</aside>
            </section>
            
          </section>

        <section>
          <section data-background='https://live.staticflickr.com/65535/40943471043_5226aa62ad_k_d.jpg'>
            <h1>Raku: Everything <strong>and</strong> the kitchen
              sink</strong></h1>
          </section>

          <section data-background='emacs.png'><h1>Took me a while</h1>
            <h2 class='fragment'>Syntax is tricky</h2>
	    <h3 class='fragment'>And there's a new Emacs mode to install</h3>
            <aside class='notes'>Rust was the most complicated, Elixir
              the simplest</aside>
          </section>

          <section><h2>But I <em>knew</em> the concepts</h2>
            <h1 class='fragment'>Because I code in Raku</h1>
          </section>

          <section data-background='https://live.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'>
	  <h1>JJ Merelo</h1>
	  <h2><code>@jjmerelo</code> <a href='https://github.com/JJ'><code>github.com/JJ</code></a></h2>
	  <aside class='notes'>Trabajo en la universidad, en la documentaci√≥n de Raku, y todo ese rollo</aside>
	  </section>

          <section><pre><code>multi sub collatz( 1 ) { return [1] }
multi sub collatz( Int $a where $a %% 2 ) { return collatz( ($a/2).Int ).prepend( $a )}
multi sub collatz( $a where not $a %% 2 ) { return collatz( $a*3 + 1 ).prepend($a)}

my @collatz = lazy gather for Ÿ°..Ÿ°Ÿ†Ÿ†Ÿ† { take collatz( $_ ); }

1..100 ==> map( { @collatz[ $_ ] }) ==> grep( *.elems > 15 ) ==> my @long-chains;

sub prefix:<‚áà> ( $ùíæ ) {
    given @collatz[ $ùíæ ].elems {
        when $_ > 15 { return @collatz[ $ùíæ ] but "15-Collatz", @collatz[ $ùíæ ].elems }
        default  { @collatz[ $ùíæ ], @collatz[ $ùíæ ].elems }
    }
}

for ^10 -> $√æ {
    my ($seq, $elems) = ‚áà$√æ;
    say "Sequence with $√æ ", $seq.?Str eq "Collatz" ?? " is " !! " is not " , "15-Collatz";
}
          </code></pre>
          <aside class='notes'><a
    href='https://es.wikipedia.org/wiki/Conjetura_de_Collatz'>Conjetura
    de Collatz</a>. Este programa tiene todas las caracter√≠sticas
    chulas de las que hemos hablado anteriormente. Y algunas que no
    tiene ninguno, como los rangos en el sentido correcto de escritura
	    y usando d√≠gitos unicode. It's better here to use context-sensible unicode, because if you don't it's like line noise.
	  </aside>

          </section>

          <section><h1>Learn Raku to learn every single language</h1>
            <h2 class='fragment'>Or at least the cool ones.</h2>
	    <aside class='notes'>You can learn also a part of Raku to learn a kind of languages, like functional, for instance.</aside>
          </section>

	</section>
	
        <section
            data-background='https://live.staticflickr.com/4748/39219833084_2a18eecdd8_k_d.jpg'><h1>Questions?</h1>
            <h2 class='fragment'>Comments?</h2>
            <aside class='notes'>"La ni√±a del huevo", de √Ångeles
            Santos, una maravilla. Espero que no os hay√°is dormido
              como ella.</aside>
        </section>

          

      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
     Reveal.initialize({
       width: '95%',
       controls: true,
       progress: true,
       history: true,
       dependencies: [
	 { src: 'plugin/markdown/marked.js' },
	 { src: 'plugin/markdown/markdown.js' },
	 { src: 'plugin/notes/notes.js', async: true },
	 { src: 'plugin/highlight/highlight.js', async: true }
       ]
     });
    </script>
  </body>
</html>
