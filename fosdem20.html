<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>FOSDEM emerging languages devroom: Let me tell you about Raku</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    <link rel="stylesheet" href="css/extra.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section data-background='https://live.staticflickr.com/2241/1576385307_b195b21468_o_d.jpg'>
	  <h1>Let me tell you about Raku</h1>
	  <h2><code>@jjmerelo</code> | <a href='https://jj.github.io/hablando-p6/fosdem.html'><code>git.io/raku-fosdem20</code></a></h2>
          <h3><code>cc-by-sa</code></h3>
	</section>

        <section data-background='https://live.staticflickr.com/619/20996949839_9be1423b2c_k_d.jpg'>
          <h1>Previously known as</h1>
          <h2 class='fragment'>Perl 6</h2>
        </section>

        <section data-background='https://live.staticflickr.com/5151/6948163750_f77c60dae6_k_d.jpg'><h2>Long story short</h2>
          <h1 class='fragment'>It's a different language</h1>
	  <aside class='notes'>As the person talking about guile said, hillclimbing is OK but eventually you get stuck. Perl was at that phase, Perl 6 was intended to take it a bit further, eventually it (almost) totally broke away with it.</aside>
        </section>

	<section data-background='https://live.staticflickr.com/7921/46812657474_b8d0df40aa_o_d.jpg'><h2>But still</h2>
	  <h1 class='fragment'>TIMTOWTDI</h1>
	  <aside class='notes'>There is more than one way to do it, and it's also the nickname of Larry Wall, creator of both.</aside>
	</section>

	<section data-background='https://live.staticflickr.com/2269/32028784543_2aec0c64d5_k_d.jpg'><h2>So</h2>
	  <h1 class='fragment'>Let me tell you about Raku</h1>
	</section>

        <section data-background='https://live.staticflickr.com/65535/2510199573_b9d6625c5c_o_d.jpg'>
          <h2>But previously</h2>
          <h1 class='fragment'>What do many cool emerging languages do?</h1>

          <aside class='notes'>Inspirado un montón por <a
        href='https://medium.com/@kasperpeulen/10-features-from-various-modern-languages-that-i-would-like-to-see-in-any-programming-language-f2a4a8ee6727'>este
            y otros artículos similares.</a>. También por <a
        href='https://therenegadecoder.com/code/the-coolest-programming-language-features/'>este
            de The Renegade Coder</a>.</aside>
        </section>
        
	<!-- Unicode -->
	<section>
	  <section data-background='https://live.staticflickr.com/65535/47925314648_9d71567b99_b_d.jpg'><h1>Unicode</h1>
	    <h2 class='fragment'>is</h2>
	    <h2 class='fragment'>important</h2>
	  </section>
	  <section><h1>It's all Greek to me</h1>
	    <pre><code>function isελληνικά(input) {
  const rελληνικά = /^\p{Script=Greek}$/u
  return rελληνικά.test(input)
}
console.log(isελληνικά('π'));
	    </code></pre>

	    <aside class='notes'> As a matter of fact, Raku is the
	  only one with good Unicode arithmetic support; many
	  languages can use unicode for strings, and some more can use
	  it for regular expressions.</aside>
	  </section>
	</section>

	<!-- Lambda -->
	  <section>
	    <section data-background='https://live.staticflickr.com/1898/42559301890_63a4eb58e8_k_d.jpg'><h1>λ FTW</h1>
              <h1>+ Immutability</h1>
	      <aside class='notes'>Funciones como datos, la esencia de
	  la programación funcional. Como explican aquí: <a
	  href='https://gist.github.com/ericelliott/414be9be82128443f6df'>lambdas
	  no sólo son funciones anónimas</a>. This is the first step
	  to a language having functional features; it's not all. Ni
	  extender, ni se puede acceder a métodos que lo cambien, ni
	  nada. Si algo parece que lo cambia, es porque se genera uno
	  nuevo. Permite trabajar con funciones puras, es más fácil de
	  testear. These are two functional features that got
	  everywhere.</section>

	    <section data-background='https://live.staticflickr.com/4806/31057964327_dc046005ee_k_d.jpg'>
	      <h2>Warning: your loops are deprecated</h2>
	      <pre><code>(def elipsis (fn [n] (print "... ", n ) ))

(defn to-zero [n]
  (if (> n 0)
    (do
      (elipsis [n])
      (to-zero (dec n))
      )
    )
  )

(to-zero 3)</code></pre>
	      <aside class='notes'>Inmutabilidad y recursión van de la mano. No hay una variable de bucle que cambie de valor, sino un argumento inmutable que pasa de una función a otra.</aside>
	    </section>
	  </section>
	  
	  <!-- Gradual typing and destructuring -->
          <section>
            <section><h1>Postmodern assignment:</h1>
              <h2 class='fragment'>Destructuring arguments</h2>
              <h2 class='fragment'>Gradual typing</h2>

              <aside class='notes'>Flexible, allows many different
            ways of dealing with variables, but it's also typesafe;
            but destructuring is also very typesafe, since you can
            create several variables out of one simple, structured,
            one. Una serie de razones por las que
            esto es chulo: <a
            href='https://css-tricks.com/new-favorite-es6-toy-destructured-objects-parameters/'>referido
                a ES6 y a argumentos de función</a></aside>
            </section>

            <section><h1>Kotlin and Derrida</h1>
              <pre><code>data class Result (val result: Int, val treasure: Boolean)
fun main(args: Array&lt;String>) {
        val search =  fun(attempt: Int): Result
        {
                val things = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( attempt == 4  ) {
                        return Result( 42, true )
                } else {
                        return Result( things[attempt], false )
                }
        }
        val (value1, prize1) = search( 2 )
        println( "2 returns " + value1 + prize( prize1 )  )
        val (value2, prize2) = search( 4 )
        println( "4 returns " + value2 + prize( prize2 )  )
}              </code></pre>
              <aside class='notes'>Por medio, <a
              href='https://stackoverflow.com/questions/56252911/i-get-the-error-no-main-manifest-attribute-when-compiling-and-running-a-simpl/56253260#56253260'>esta
                  pregunta en StackOverflow</a>. También usamos un
              lambda. Derrida is the father of <a href='https://en.wikipedia.org/wiki/Jacques_Derrida'>Deconstruction</a></aside>
            </section>
          </section>
          
	  <!-- Pattern matching -->
          <section>
          <section data-background='https://live.staticflickr.com/98/248298523_e53c4a51a2_o_d.jpg'>
            <h1>Pattern matching for complex decisions</h1>
            <h2 class='fragment'>Avoiding <code>if</code> cascades</h2>
          </section>
          <section><h1>Scala-ing comparison</h1>
            <pre><code>val points = (card: String) => {
  card match {
    case "Ace" => 11
    case "3"  => 10
    case "J"  => 2
    case "Q"  => 3
    case "K"  => 4
    case  _   => 0
  }
}

println("Ace ", points("Ace"))
println("7 ", points("7"))</code></pre><aside class='notes'>Usando también un lambda
              aquí, como casi siempre. La mayoría de los lenguajes
              funcionales tienen este tipo de comparación de
              patrones. Sorprendentemente, este programa salió a la
              primera. Pero a veces hay que enganchar las entradas de
              uno con las salidas de otro...</aside>
          </section>
          </section>

	  <!-- Multiple dispatch -->
          <section>
            <section><h1>Multiple dispatch</h1>
              <h2 class='fragment'>High performance implementation at your
                service</h2>
              <aside class='notes'>No es lo mismo que <a
              href='http://wiki.c2.com/?MultipleDispatch'>Overloading</a>,
              porque se puede hacer con subrutinas y se trata de
                identificar los argumentos, no el tipo que lo invoca. Although at the end of the day the object is another argument, so it¡s pretty much the same.
	      </aside>

            </section>

            <section><h1>Suit up with Julia</h1>
              <pre><code>@enum Suit ♣ ♦ ♥ ♠
@enum Palo Bastos Espadas Oros Copas

toString( n::Int, s::Suit ) = string( n, " ", s )
toString( n::Int, p::Palo ) = string( n, " de ", p )

println( toString( 3, ♦) )
println( toString( 7, Bastos ) ) </code></pre>
              <aside class='notes'>Hay muchos tipos de envío múltiple
              que varían con la signatura, lo que ocurre es que la
              signatura tiene un concepto mucho más concreto en Julia
              que en Raku, donde incluye también restricciones a los
                valores de los argumentos. </aside>
            </section>
          </section>

	  <!-- Laziness and cascading -->
          <section>
            <section data-background='https://live.staticflickr.com/1847/43736329804_1ab7461a70_k_d.jpg'>
	      <h1>Sloths will inherit the earth</h1>
              <h2 class='fragment'>Lazy evaluation FTW</h2>
              <h2 class='fragment'>Great for propagating: cascading</h2>
	      
              <aside class='notes'>Otra característica (más) de
          programación funcional, permite trabajar con estructuras de
                datos infinitas y retrasar la evaluación hasta que sea
          necesaria. Puede tener <a
          href='https://softwareengineering.stackexchange.com/questions/124500/why-isnt-lazy-evaluation-used-everywhere'>una
                serie de desventajas</a>, sin embargo. Más <a
          href='https://www.seas.upenn.edu/~cis194/fall16/lectures/07-laziness.html'>ventajas
                  y desventajas. I am also too lazy to look up a picture of a sloth, so you'll have to make do with plush penguins, which are lovely
	      </a></aside>
            </section>

            <section><h1>Lazy and cascaded in F#</h1>
              <pre><code>let horadam =
    (0.0f, 1.0f) 
    |> Seq.unfold (fun (x, y) -> let z = 0.25f*x + 0.75f*y in Some(z, (y, z))) 
    |> Seq.append [0.0f; 1.0f]


let seq_15 = horadam |> Seq.take 15
printfn "First 15 %A" seq_15
              </code></pre>
              <aside class='notes'>También se usan lambdas y "pipes",
                dos cosas características de programación
                funcional. El hecho de que sea infinita está implícita
                en la definición de la estructura de datos, que es una
                secuencia. F# no es perezoso por omisión como Haskell,
                pero permite trabajar fácilmente con este tipo de
                cosas. </aside>
            </section>
          </section>
          
	  <!-- Traits (with type tunnelling) -->
          <section>
            <section><h1>Inheriting << composing</h1>
              <h2 class='fragment'><em>Traits</em>, <em>mixins</em> and
                roles</h2>
              <aside class='notes'>Aunque cada lenguaje usa su
          definición, aparentemente los traits son interfaces
          abstractos y no incluyen estado, mientras que los mixins
          sí. En algunos lugares se les llama modules (en Ruby). Roles
                aparentemente pueden ser o una cosa o la otra.</aside>
            </section>

            <section><h1>Safe Rust-y traits</h1>
              <pre><code>struct Card { value: String, suit: &'static str }

trait Lookup {
    fn lookup(self ) -> String;
}

impl Lookup for Card  {
    fn lookup(self ) -> String {
        self.value + " of " + self.suit
    }
}

fn main() {
    let ace_of_clubs = Card { value: "Ace".to_string(),
                               suit: "♣"
    };
    println!( "Card → {}", ace_of_clubs.lookup() );
}

              </code></pre>
              <aside class='notes'>Aunque en realidad los de Raku
    son bastante más flexibles y se pueden añadir en tiempo de
    ejecución, esto es lo que hay en Rust, donde además se separan las
    variables de instancia de la implementación. Y con esto terminan
    las diez características chulas. Hay muchas más, pero estas son
                bastante sobresalientes.</aside>
            </section>
            
          </section>

        <section>
          <section data-background='https://live.staticflickr.com/65535/40943471043_5226aa62ad_k_d.jpg'>
            <h1>Raku: Everything <strong>and</strong> the kitchen
              sink</strong></h1>
          </section>

          <section data-background='emacs.png'><h1>Took me a while</h1>
            <h2 class='fragment'>Syntax is tricky</h2>
	    <h3 class='fragment'>And there's a new Emacs mode to install</h3>
            <aside class='notes'>Rust was the most complicated, Elixir
              the simplest</aside>
          </section>

          <section><h2>But I <em>knew</em> the concepts</h2>
            <h1 class='fragment'>Because I code in Raku</h1>
          </section>

          <section data-background='https://live.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'>
	  <h1>JJ Merelo</h1>
	  <h2><code>@jjmerelo</code> <a href='https://github.com/JJ'><code>github.com/JJ</code></a></h2>
	  <aside class='notes'>Trabajo en la universidad, en la documentación de Raku, y todo ese rollo</aside>
	  </section>

          <section><pre><code>multi sub collatz( 1 ) { return [1] }
multi sub collatz( Int $a where $a %% 2 ) { return collatz( ($a/2).Int ).prepend( $a )}
multi sub collatz( $a where not $a %% 2 ) { return collatz( $a*3 + 1 ).prepend($a)}

my @collatz = lazy gather for ١..١٠٠٠ { take collatz( $_ ); }

1..100 ==> map( { @collatz[ $_ ] }) ==> grep( *.elems > 15 ) ==> my @long-chains;

sub prefix:<⇈> ( $𝒾 ) {
    given @collatz[ $𝒾 ].elems {
        when $_ > 15 { return @collatz[ $𝒾 ] but "15-Collatz", @collatz[ $𝒾 ].elems }
        default  { @collatz[ $𝒾 ], @collatz[ $𝒾 ].elems }
    }
}

for ^10 -> $þ {
    my ($seq, $elems) = ⇈$þ;
    say "Sequence with $þ ", $seq.?Str eq "Collatz" ?? " is " !! " is not " , "15-Collatz";
}
          </code></pre>
          <aside class='notes'><a
    href='https://es.wikipedia.org/wiki/Conjetura_de_Collatz'>Conjetura
    de Collatz</a>. Este programa tiene todas las características
    chulas de las que hemos hablado anteriormente. Y algunas que no
    tiene ninguno, como los rangos en el sentido correcto de escritura
	    y usando dígitos unicode. It's better here to use context-sensible unicode, because if you don't it's like line noise.
	  </aside>

          </section>

          <section><h1>Learn Raku to learn every single language</h1>
            <h2 class='fragment'>Or at least the cool ones.</h2>
	    <aside class='notes'>You can learn also a part of Raku to learn a kind of languages, like functional, for instance.</aside>
          </section>

	</section>
	
        <section
            data-background='https://live.staticflickr.com/4748/39219833084_2a18eecdd8_k_d.jpg'><h1>Questions?</h1>
            <h2 class='fragment'>Comments?</h2>
            <aside class='notes'>"La niña del huevo", de Ángeles
            Santos, una maravilla. Espero que no os hayáis dormido
              como ella.</aside>
        </section>

          

      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
     Reveal.initialize({
       width: '95%',
       controls: true,
       progress: true,
       history: true,
       dependencies: [
	 { src: 'plugin/markdown/marked.js' },
	 { src: 'plugin/markdown/markdown.js' },
	 { src: 'plugin/notes/notes.js', async: true },
	 { src: 'plugin/highlight/highlight.js', async: true }
       ]
     });
    </script>
  </body>
</html>
