<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Open South Code: D√©jame que te hable de Perl 6</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    <link rel="stylesheet" href="css/extra.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section><h1>D√©jame que te hable de Perl 6</h1>
	  <h2><code>@jjmerelo</code></h2>
	</section>

        <section><h1>Primero</h1>
          <h2>Hablemos de lo que hacen los lenguajes modernos que molan</h2>

          <aside class='notes'>Inspirado un mont√≥n por <a
        href='https://medium.com/@kasperpeulen/10-features-from-various-modern-languages-that-i-would-like-to-see-in-any-programming-language-f2a4a8ee6727'>este
            y otros art√≠culos similares.</a>. Tambi√©n por <a
        href='https://therenegadecoder.com/code/the-coolest-programming-language-features/'>este
            de The Renegade Coder</a>.</aside>
        </section>
        
	<!-- Unicode -->
	<section>
	  <section data-background='https://live.staticflickr.com/21/24491789_c9692abd5d_o_d.jpg'><h1>Unicode</h1>
	    <h2 class='fragment'>es</h2>
	    <h2 class='fragment'>importante</h2>
	  </section>
	  <section><h1>Me suena a griego</h1>
	    <pre><code>function isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨(input) {
  const rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ = /^\p{Script=Greek}$/u
  return rŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨.test(input)
}
console.log(isŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨('œÄ'));
	    </code></pre>

	    <aside class='notes'>He tratado de buscar soporte en alg√∫n lenguaje para aritm√©tica con d√≠gitos unicode, y no lo he encontrado.</aside>
	  </section>
	</section>

	<!-- Lambda -->
	  <section>
	    <section><h1>Œª FTW</h1>
	      <aside class='notes'>Funciones como datos, la esencia de la programaci√≥n funcional. Como explican aqu√≠: <a href='https://gist.github.com/ericelliott/414be9be82128443f6df'>lambdas no s√≥lo son funciones an√≥nimas</a>. </aside>
	    </section>
	    
	    <section><h1>Œª es lambda</h1>
	      <pre><code>from functools import reduce;

def fib(n):
    return reduce( lambda prev,this: prev+[ prev[-2]+prev[-1] ], \
                   range(1,n+1), \
                   [1,1] )

print(fib(12))
	      </code></pre>
	      <aside class='notes'>Se usa reduce con tres argumentos, el primero de los cuales es el inicializador. Lambda est√° ah√≠ desde la versi√≥n 3, pero tambi√©n en Java desde la 7, y creo que ahora hasta en C++</aside>
	    </section>
	  </section>
	  
	  <!-- Inmutabilidad -->
	  <section>
	    <section><h1>Inmutabilidad para programaci√≥n r√°pida y segura</h1>
	    </section>
	    
	    <section><h1>Lo que es inmutable no se puede cambiar</h1>
	      <aside class='notes'>Ni extender, ni se puede acceder a m√©todos que lo cambien, ni nada. Si algo parece que lo cambia, es porque se genera uno nuevo. Permite trabajar con funciones puras, es m√°s f√°cil de testear.</aside>
	    </section>
	    <section><h1>Escalando la inmutabilidad</h1>
	      <pre><code>val no = "me cambies"</code></pre>
	    </section>
	    <section><h1>¬øBucles? No, gracias.</h1>
	      <pre><code>(defn hasta-cero [n]
  (if (> n 0)
    (do
      (print n, "... ")
      (hasta-cero (dec n))
      )
    )
  )

(hasta-cero 3)
	      </code></pre>
	      <aside class='notes'>Inmutabilidad y recursi√≥n van de la mano. No hay una variable de bucle que cambie de valor, sino un argumento inmutable que pasa de una funci√≥n a otra.</aside>
	    </section>
	  </section>
	  
	  <!-- Gradual typing -->
	  <section>
            <section><h1>Tipado gradual: lo mejor de los dos
	      mundos</h1>
              <h2 class='fragment'>Est√°tico: <code>let secondNeedle: number =
	  3</code></h2>
              <h2 class='fragment'>Din√°mico: <code>let firstNeedle = "Hey"</code></h2>
            </section>
            <section><h1>Juntos en TypeScript</h1>
              <pre><code>let find = function ( needle, haystack ) {
    for (let i of haystack) {
        if ( needle === i ) {
            return true
        }
    }
    return false;
}
let randomList = ["Hey", 3]
let firstNeedle = "Hey"
let secondNeedle: number = 3
console.log( find( firstNeedle, randomList ) )
console.log( find( secondNeedle, randomList  ) )
              </code></pre>
                <aside class='notes'>N√≥tese que tambi√©n tenemos una
	  lambda ah√≠ al principio. Informaci√≥n sobre <a
	          href='https://golem.ph.utexas.edu/category/2018/02/gradual_typing.html'>gradual typing</a></aside>
            </section>
          </section>
          
	  <!-- Destructuring -->
          <section>
            <section><h1>Asignaci√≥n postmoderna: desestructurando
              argumentos</h1>
              <h2 class='fragment'>Facilitando asignaci√≥n en una sola
                orden</h2>
              <h2 class='fragment'>Y con seguridad</h2>
              <aside class='notes'>Una serie de razones por las que
            esto es chulo: <a
            href='https://css-tricks.com/new-favorite-es6-toy-destructured-objects-parameters/'>referido
                a ES6 y a argumentos de funci√≥n</a></aside>
            </section>

            <section><h1>Desestructurando en Kotlin</h1>
              <pre><code>data class Resultado (val resultado: Int, val tesoro: Boolean)
fun main(args: Array&lt;String>) {
        val busca =  fun(intento: Int): Resultado
        {
                val cosas = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( intento == 4  ) {
                        return Resultado( 42, true )
                } else {
                        return Resultado( cosas[intento], false )
                }
        }
        val (valor1, premio1) = busca( 2 )
        println( "2 devuelve " + valor1 + " y tiene premio " + premio1  )
        val (valor2, premio2) = busca( 4 )
        println( "4 devuelve " + valor2 + " y tiene premio " + premio2  )
}
              </code></pre>
              <aside class='notes'>Por medio, <a
              href='https://stackoverflow.com/questions/56252911/i-get-the-error-no-main-manifest-attribute-when-compiling-and-running-a-simpl/56253260#56253260'>esta
                pregunta en StackOverflow</a>. Tambi√©n usamos un lambda.</aside>
            </section>
          </section>
          
	  <!-- Pattern matching -->
          <section>
          <section>
            <h1>Comparaci√≥n de patrones para decisiones complejas</h1>
            <h2 class='fragment'>Evitando cascadas de
              <code>if</code></h2>
          </section>
          <section><h1>Scalando la comparaci√≥n</h1>
            <pre><code>val puntos = (carta: String) => {
  carta match {
    case "As" => 11
    case "3"  => 10
    case "J"  => 2
    case "Q"  => 3
    case "K"  => 4
    case  _   => 0
  }
}

println("As ", puntos("A"))
println("7 ", puntos("7"))
            </code></pre><aside class='notes'>Usando tambi√©n un lambda
              aqu√≠, como casi siempre. La mayor√≠a de los lenguajes
              funcionales tienen este tipo de comparaci√≥n de
              patrones. Sorprendentemente, este programa sali√≥ a la
              primera. Pero a veces hay que enganchar las entradas de
              uno con las salidas de otro...</aside>
          </section>
          </section>
          
	  <!-- Pipeline/Cascade operators -->

          <section>
            <section><h1>Cuando hay que enganchar operaciones:
              cascadas</h1>
              <aside class='notes'>Se trata de otra caracter√≠stica de
            programaci√≥n funcional, como casi todo. Esta funcionalidad
            te permite "seguir" el flujo de los datos f√°cilmente, pero
            tambi√©n te fuerza a pensar en t√©rminos de aplicaciones de
                unos dominios a otros dominios.</aside>
            </section>
            <section><h1>Tengo un Elixir para eso</h1>
              <pre><code>resultado = 1..100
      |> Enum.filter(fn a -> rem(a,2) == 0 end)
      |> Enum.map(fn a -> :math.pow(a,2) end)
      |> Enum.reduce( &(&1 + &2) )

IO.puts  resultado
              </code></pre> <aside class='notes'>Obs√©rvese no s√≥lo el
              uso de lambdas, sino el uso de las mismas con datos
                impl√≠citos. Otra cosa funcional a la buchaca</aside>
            </section>
          </section>
          
	  <!-- Multiple dispatch -->
          <section>
            <section><h1>Env√≠o m√∫ltiple ‚áí <em>Multiple
              dispatch</em></h1>
              <h2 class='fragment'>Implementaciones r√°pidas a su
                servicio</h2>
              <aside class='notes'>No es lo mismo que <a
              href='http://wiki.c2.com/?MultipleDispatch'>Overloading</a>,
              porque se puede hacer con subrutinas y se trata de
                identificar los argumentos, no el tipo que lo invoca.</aside>
              
            </section>

            <section><h1>Pintan bastos con Julia</h1>
              <pre><code>@enum Suit ‚ô£ ‚ô¶ ‚ô• ‚ô†
@enum Palo Bastos Espadas Oros Copas

cadena( n::Int, s::Suit ) = string( n, " ", s )
cadena( n::Int, p::Palo ) = string( n, " de ", p )

println( cadena( 3, ‚ô¶) )
println( cadena( 7, Bastos ) )
            </code></pre>
              <aside class='notes'>Hay muchos tipos de env√≠o m√∫ltiple
              que var√≠an con la signatura, lo que ocurre es que la
              signatura tiene un concepto mucho m√°s concreto en Julia
              que en Perl 6, donde incluye tambi√©n restricciones a los
                valores de los argumentos.</aside>
            </section>
          </section>

	  <!-- Laziness -->
          <section>
            <section><h1>Los perezosos heredar√°n la Tierra</h1>
              <h2 class='fragment'>Evaluaci√≥n perezosa FTW</h2>
              <aside class='notes'>Otra caracter√≠stica (m√°s) de
          programaci√≥n funcional, permite trabajar con estructuras de
                datos infinitas y retrasar la evaluaci√≥n hasta que sea
          necesaria. Puede tener <a
          href='https://softwareengineering.stackexchange.com/questions/124500/why-isnt-lazy-evaluation-used-everywhere'>una
                serie de desventajas</a>, sin embargo. M√°s <a
          href='https://www.seas.upenn.edu/~cis194/fall16/lectures/07-laziness.html'>ventajas
                y desventajas</a></aside>
            </section>

            <section><h1>Pereza en F#</h1>
              <pre><code>let horadam =
    (0.0f, 1.0f) 
    |> Seq.unfold (fun (x, y) -> let z = 0.25f*x + 0.75f*y in Some(z, (y, z))) 
    |> Seq.append [0.0f; 1.0f]


let seq_15 = horadam |> Seq.take 15
printfn "Primeros 15 %A" seq_15
              </code></pre>
              <aside class='notes'>Tambi√©n se usan lambdas y "pipes",
                dos cosas caracter√≠sticas de programaci√≥n
                funcional. El hecho de que sea infinita est√° impl√≠cita
                en la definici√≥n de la estructura de datos, que es una
                secuencia. F# no es perezoso por omisi√≥n como Haskell,
                pero permite trabajar f√°cilmente con este tipo de
                cosas. </aside>
            </section>
          </section>
          
	  <!-- Traits (with type tunnelling) -->
          <section>
            <section><h1>Composici√≥n mejor que herencia</h1>
              <h2 class='fragment'><em>Traits</em>, <em>mixins</em> y
                roles</h2>
              <aside class='notes'>Aunque cada lenguaje usa su
          definici√≥n, aparentemente los traits son interfaces
          abstractos y no incluyen estado, mientras que los mixins
          s√≠. En algunos lugares se les llama modules (en Ruby). Roles
                aparentemente pueden ser o una cosa o la otra.</aside>
            </section>

            <section><h1>Traits seguros con Rust</h1>
              <pre><code>struct Carta { figura: String, palo: &'static str }

trait Mira {
    fn mira(self ) -> String;
}

impl Mira for Carta  {
    fn mira(self ) -> String {
        self.figura + " de " + self.palo
    }
}

fn main() {
    let as_de_bastos = Carta { figura: "As".to_string(),
                               palo: "Bastos"
    };
    println!( "Carta ‚Üí {}", as_de_bastos.mira() );
}
              </code></pre>
              <aside class='notes'>Aunque en realidad los de Perl 6
    son bastante m√°s flexibles y se pueden a√±adir en tiempo de
    ejecuci√≥n, esto es lo que hay en Rust, donde adem√°s se separan las
    variables de instancia de la implementaci√≥n. Y con esto terminan
    las diez caracter√≠sticas chulas. Hay muchas m√°s, pero estas son
                bastante sobresalientes.</aside>
            </section>
            
          </section>

	<section data-background='https://live.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'>
	  <h1>JJ Merelo</h1>
	  <h2><code>@jjmerelo</code> <a href='https://github.com/JJ'><code>github.com/JJ</code></a></h2>
	  <aside class='notes'>Trabajo en la universidad, en la documentaci√≥n de Perl 6, y todo ese rollo</aside>
	</section>

        <section>
          <section><h1>¬ø1¬™ vez que se menciona Perl 6?</h1></section>
          <section><h1>No</h1>
            <h2 class='notes'>Todas esas son funcionalidades de Perl
              6</h2>
          </section>
          <section><h1>Tard√© un rato en hacerlos</h1>
            <h2 class='notes'>Pero no por el concepto, sino por la
              sintaxis</h2>
            <aside class='notes'>Bueno, y por descargar el modo en
          emacs, instalar el programa en s√≠... El que m√°s ha costado
              ha sido Rust, y el que menos Elixir.</aside>
          </section>
        </section>

        <section>
          <section>
            <h1>Perl 6: todo <strong>y adem√°s, el
              fregadero</strong></h1></section>
          <section><pre><code>multi sub collatz( 1 ) { return [1] }
multi sub collatz( Int $a where $a %% 2 ) { return  collatz( ($a/2).Int ).prepend( $a )}
multi sub collatz( $a where not $a %% 2 ) { return collatz( $a*3 + 1 ).prepend($a)}

my @collatz = lazy gather for Ÿ°..Ÿ°Ÿ†Ÿ†Ÿ† { take collatz( $_ ); }

1..100 ==> map( { @collatz[ $_ ] }) ==> grep( *.elems > 15 ) ==> my @long-chains;

sub prefix:<‚áà> ( $ùíæ ) {
    given @collatz[ $ùíæ ].elems {
        when $_ > 15 { return @collatz[ $ùíæ ] but "Collatz", @collatz[ $ùíæ ].elems }
        default  { @collatz[ $ùíæ ], @collatz[ $ùíæ ].elems }
    }
}

for ^10 -> $√æ {
    my ($seq, $elems) = ‚áà$√æ;
    say "Secuencia con $√æ ", $seq.?Str eq "Collatz" ?? " es " !! " no es " , "Collatz";
}
          </code></pre>
          <aside class='notes'><a
    href='https://es.wikipedia.org/wiki/Conjetura_de_Collatz'>Conjetura
    de Collatz</a>. Este programa tiene todas las caracter√≠sticas
    chulas de las que hemos hablado anteriormente. Y algunas que no
    tiene ninguno, como los rangos en el sentido correcto de escritura
    y usando d√≠gitos unicode.</aside>

          </section>
          <section><h1>Aprende Perl 6 para aprender <em>todos</em> los
            lenguajes</h1>
            <h2 class='fragment'>O al menos los que molan</h2>
          </section>

          <section><h1>¬øPreguntas?</h1></section>
        </section>
          

      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
     Reveal.initialize({
       width: '95%',
       controls: true,
       progress: true,
       history: true,
       dependencies: [
	 { src: 'plugin/markdown/marked.js' },
	 { src: 'plugin/markdown/markdown.js' },
	 { src: 'plugin/notes/notes.js', async: true },
	 { src: 'plugin/highlight/highlight.js', async: true }
       ]
     });
    </script>
  </body>
</html>
