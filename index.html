<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Open South Code: Déjame que te hable de Perl 6</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    <link rel="stylesheet" href="css/extra.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section><h1>Déjame que te hable de Perl 6</h1>
	  <h2><code>@jjmerelo</code></h2>
	</section>

        <section><h1>Primero</h1>
          <h2>Hablemos de lo que hacen los lenguajes que molan</h2>

          <aside class='notes'>Inspirado un montón por <a
        href='https://medium.com/@kasperpeulen/10-features-from-various-modern-languages-that-i-would-like-to-see-in-any-programming-language-f2a4a8ee6727'>este
            y otros artículos similares.</a></aside>
        </section>
        
	<!-- Unicode -->
	<section>
	  <section data-background='https://live.staticflickr.com/21/24491789_c9692abd5d_o_d.jpg'><h1>Unicode</h1>
	    <h2 class='fragment'>es</h2>
	    <h2 class='fragment'>importante</h2>
	  </section>
	  <section><h1>Me suena a griego</h1>
	    <pre><code>function isελληνικά(input) {
  const rελληνικά = /^\p{Script=Greek}$/u
  return rελληνικά.test(input)
}
console.log(isελληνικά('π'));
	    </code></pre>

	    <aside class='notes'>He tratado de buscar soporte en algún lenguaje para aritmética con dígitos unicode, y no lo he encontrado.</aside>
	  </section>
	</section>

	<!-- Lambda -->
	  <section>
	    <section><h1>λ FTW</h1>
	      <aside class='notes'>Funciones como datos, la esencia de la programación funcional. Como explican aquí: <a href='https://gist.github.com/ericelliott/414be9be82128443f6df'>lambdas no sólo son funciones anónimas</a>. </aside>
	    </section>
	    
	    <section><h1>λ es lambda</h1>
	      <pre><code>from functools import reduce;

def fib(n):
    return reduce( lambda prev,this: prev+[ prev[-2]+prev[-1] ], \
                   range(1,n+1), \
                   [1,1] )

print(fib(12))
	      </code></pre>
	      <aside class='notes'>Se usa reduce con tres argumentos, el primero de los cuales es el inicializador. Lambda está ahí desde la versión 3, pero también en Java desde la 7, y creo que ahora hasta en C++</aside>
	    </section>
	  </section>
	  
	  <!-- Inmutabilidad -->
	  <section>
	    <section><h1>Inmutabilidad para programación rápida y segura</h1>
	    </section>
	    
	    <section><h1>Lo que es inmutable no se puede cambiar</h1>
	      <aside class='notes'>Ni extender, ni se puede acceder a métodos que lo cambien, ni nada. Si algo parece que lo cambia, es porque se genera uno nuevo. Permite trabajar con funciones puras, es más fácil de testear.</aside>
	    </section>
	    <section><h1>Escalando la inmutabilidad</h1>
	      <pre><code>val no = "me cambies"</code></pre>
	    </section>
	    <section><h1>¿Bucles? No, gracias.</h1>
	      <pre><code>(defn hasta-cero [n]
  (if (> n 0)
    (do
      (print n, "... ")
      (hasta-cero (dec n))
      )
    )
  )

(hasta-cero 3)
	      </code></pre>
	      <aside class='notes'>Inmutabilidad y recursión van de la mano. No hay una variable de bucle que cambie de valor, sino un argumento inmutable que pasa de una función a otra.</aside>
	    </section>
	  </section>
	  
	  <!-- Gradual typing -->
	  <section>
            <section><h1>Tipado gradual: lo mejor de los dos
	      mundos</h1>
              <h2 class='fragment'>Estático: <code>let secondNeedle: number =
	  3</code></h2>
              <h2 class='fragment'>Dinámico: <code>let firstNeedle = "Hey"</code></h2>
            </section>
            <section><h1>Juntos en TypeScript</h1>
              <pre><code>let find = function ( needle, haystack ) {
    for (let i of haystack) {
        if ( needle === i ) {
            return true
        }
    }
    return false;
}
let randomList = ["Hey", 3]
let firstNeedle = "Hey"
let secondNeedle: number = 3
console.log( find( firstNeedle, randomList ) )
console.log( find( secondNeedle, randomList  ) )
              </code></pre>
                <aside class='notes'>Nótese que también tenemos una
	  lambda ahí al principio. Información sobre <a
	          href='https://golem.ph.utexas.edu/category/2018/02/gradual_typing.html'>gradual typing</a></aside>
            </section>
          </section>
	  <!-- Destructuring -->

          <section>
            <section><h1>Asignación postmoderna: desestructurando
              argumentos</h1>
              <h2 class='fragment'>Facilitando asignación en una sola
                orden</h2>
              <h2 class='fragment'>Y con seguridad</h2>
              <aside class='notes'>Una serie de razones por las que
            esto es chulo: <a
            href='https://css-tricks.com/new-favorite-es6-toy-destructured-objects-parameters/'>referido
                a ES6 y a argumentos de función</a></aside>
            </section>

            <section><h1>Desestructurando en Kotlin</h1>
              <pre><code>data class Resultado (val resultado: Int, val tesoro: Boolean)
fun main(args: Array&lt;String>) {
        val busca =  fun(intento: Int): Resultado
        {
                val cosas = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( intento == 4  ) {
                        return Resultado( 42, true )
                } else {
                        return Resultado( cosas[intento], false )
                }
        }
        val (valor1, premio1) = busca( 2 )
        println( "2 devuelve " + valor1 + " y tiene premio " + premio1  )
        val (valor2, premio2) = busca( 4 )
        println( "4 devuelve " + valor2 + " y tiene premio " + premio2  )
}
              </code></pre>
              <aside class='notes'>Por medio, <a
              href='https://stackoverflow.com/questions/56252911/i-get-the-error-no-main-manifest-attribute-when-compiling-and-running-a-simpl/56253260#56253260'>esta
                pregunta en StackOverflow</a>. También usamos un lambda.</aside>
            </section>
          </section>
          
	  <!-- Pattern matching -->
          <section>
          <section>
            <h1>Comparación de patrones para decisiones complejas</h1>
            <h2 class='fragment'>Evitando cascadas de
              <code>if</code></h2>
          </section>
          <section><h1>Scalando la comparación</h1>
            <pre><code>val puntos = (carta: String) => {
  carta match {
    case "As" => 11
    case "3"  => 10
    case "J"  => 2
    case "Q"  => 3
    case "K"  => 4
    case  _   => 0
  }
}

println("As ", puntos("A"))
println("7 ", puntos("7"))
            </code></pre><aside class='notes'>Usando también un lambda
              aquí, como casi siempre. La mayoría de los lenguajes
              funcionales tienen este tipo de comparación de
              patrones. Sorprendentemente, este programa salió a la
              primera. Pero a veces hay que enganchar las entradas de
              uno con las salidas de otro...</aside>
          </section>
          </section>
          
	  <!-- Pipeline/Cascade operators -->

          <section>
            <section><h1>Cuando hay que enganchar operaciones:
              cascadas</h1>
              <aside class='notes'>Se trata de otra característica de
            programación funcional, como casi todo. Esta funcionalidad
            te permite "seguir" el flujo de los datos fácilmente, pero
            también te fuerza a pensar en términos de aplicaciones de
                unos dominios a otros dominios.</aside>
            </section>
            <section><h1>Tengo un Elixir para eso</h1>
              <pre><code>resultado = 1..100
      |> Enum.filter(fn a -> rem(a,2) == 0 end)
      |> Enum.map(fn a -> :math.pow(a,2) end)
      |> Enum.reduce( &(&1 + &2) )

IO.puts  resultado
              </code></pre> <aside class='notes'>Obsérvese no sólo el
              uso de lambdas, sino el uso de las mismas con datos
                implícitos. Otra cosa funcional a la buchaca</aside>
            </section>
          </section>
	<!-- Multiple dispatch -->
	<!-- Laziness -->
	<!-- Traits (with type tunnelling) -->

	<section data-background='https://live.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'>
	  <h1>JJ Merelo</h1>
	  <h2><code>@jjmerelo</code> <a href='https://github.com/JJ'><code>github.com/JJ</code></a></h2>
	  <aside class='notes'>Trabajo en la universidad, en la documentación de Perl 6, y todo ese rollo</aside>
	</section>
	

	    </div>
	  </div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			width: '95%',
			controls: true,
			progress: true,
			history: true,
			dependencies: [
			{ src: 'plugin/markdown/marked.js' },
			{ src: 'plugin/markdown/markdown.js' },
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true }
			]
			});
		</script>
	</body>
</html>
